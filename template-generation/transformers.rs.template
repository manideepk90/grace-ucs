use common_enums::AttemptStatus;
use serde::{Deserialize, Serialize};
use hyperswitch_masking::{Secret};
use domain_types::{
    connector_flow::Authorize,
    connector_types::{
        PaymentFlowData, PaymentsAuthorizeData, PaymentsResponseData, ResponseId,
    },
    errors,
    payment_method_data::PaymentMethodDataTypes,
    router_data::ConnectorAuthType,
    router_data_v2::RouterDataV2,
};
use crate::types::ResponseRouterData;

#[derive(Debug, Clone)]
pub struct {{CONNECTOR_NAME_PASCAL}}AuthType {
    pub api_key: Secret<String>,
}

impl TryFrom<&ConnectorAuthType> for {{CONNECTOR_NAME_PASCAL}}AuthType {
    type Error = error_stack::Report<errors::ConnectorError>;

    fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {
        match auth_type {
            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {
                api_key: api_key.to_owned(),
            }),
            _ => Err(error_stack::report!(errors::ConnectorError::FailedToObtainAuthType)),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{CONNECTOR_NAME_PASCAL}}ErrorResponse {
    pub code: String,
    pub message: String,
}

#[derive(Debug, Serialize)]
pub struct {{CONNECTOR_NAME_PASCAL}}PaymentsRequest {
    pub amount: i64,
    pub currency: String,
    pub reference: String,
}

impl<T: PaymentMethodDataTypes>
    TryFrom<&RouterDataV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>>
    for {{CONNECTOR_NAME_PASCAL}}PaymentsRequest
{
    type Error = error_stack::Report<errors::ConnectorError>;

    fn try_from(
        item: &RouterDataV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>,
    ) -> Result<Self, Self::Error> {
        Ok(Self {
            amount: item.request.minor_amount.get_amount_as_i64(),
            currency: item.request.currency.to_string(),
            reference: item.resource_common_data.connector_request_reference_id.clone(),
        })
    }
}

#[derive(Debug, Deserialize, Serialize)]
pub struct {{CONNECTOR_NAME_PASCAL}}PaymentsResponse {
    pub id: String,
    pub status: String,
    pub amount: i64,
    pub currency: String,
}

impl<T: PaymentMethodDataTypes>
    TryFrom<ResponseRouterData<{{CONNECTOR_NAME_PASCAL}}PaymentsResponse, RouterDataV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>>>
    for RouterDataV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>
{
    type Error = error_stack::Report<errors::ConnectorError>;

    fn try_from(
        item: ResponseRouterData<{{CONNECTOR_NAME_PASCAL}}PaymentsResponse, RouterDataV2<Authorize, PaymentFlowData, PaymentsAuthorizeData<T>, PaymentsResponseData>>,
    ) -> Result<Self, Self::Error> {
        let status = match item.response.status.as_str() {
            "succeeded" | "completed" => AttemptStatus::Charged,
            "pending" | "processing" => AttemptStatus::Pending,
            "failed" | "error" => AttemptStatus::Failure,
            "cancelled" => AttemptStatus::Voided,
            _ => AttemptStatus::Pending,
        };
        
        Ok(Self {
            response: Ok(PaymentsResponseData::TransactionResponse {
                resource_id: ResponseId::ConnectorTransactionId(item.response.id),
                redirection_data: None,
                mandate_reference: None,
                connector_metadata: None,
                network_txn_id: None,
                connector_response_reference_id: None,
                incremental_authorization_allowed: None,
                status_code: item.http_code,
            }),
            resource_common_data: PaymentFlowData {
                status,
                ..item.router_data.resource_common_data
            },
            ..item.router_data
        })
    }
}